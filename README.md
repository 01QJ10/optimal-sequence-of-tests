# Optimal Sequence of Tests

[![DOI](https://img.shields.io/badge/DOI-10.2139%2Fssrn.5118887-blue)](https://dx.doi.org/10.2139/ssrn.5118887)

This repository implements methods for selecting an optimal subset of tests (questions, measurements, etc.) to minimize posterior variance, as introduced by Lim, Keppo, and Tan ([papers.ssrn.com](https://papers.ssrn.com/sol3/papers.cfm?abstract_id=5118887&utm_source=chatgpt.com)). Two approaches are provided:

1. **Fast (prefix) method** based on Definition 1 and Corollary 6 from the paper.
2. **Slow (brute-force) method** using Lemma 9 from the paper.

---

## Repository Structure

```
- code
    - demo.ipynb
    - preprocess.ipynb
    - testSamples.py        # Utilities for testing diagonal-dominance
    - module.py             # Core functions: is_diagonally_dominant, optimal_test_selection
    - main.py               # CLI to load data, select sequence, write output
- tests
    - diagonalMatrices      # Invertible matrices for positive tests
    - nonDiagonalMatrices   # Matrices failing the diagonal-dominance check
- output                    # Results generated by `main.py` go here
- data
    - normalTests.csv       # Input CSV for `main.py` (questions + numeric data)
    - log_normality_results.csv
    - normality_results.csv
    - normality_test.xlsx
```

---

## Instructions

1. **Prepare your input CSV** by running `preprocess.ipynb`.  The cleaned `normalTests.csv` must have:

   | Test Name    | Q1 Description                            | Q2 Description | … |
   | ------------ | ----------------------------------------- | -------------- | - |
   | **Header:**  | names of tests (e.g. “CSQ-VSF Globality”) | …              |   |
   | **Row 1:**   | textual question or prompt for each test  | …              |   |
   | **Rows 2+:** | numeric scores for each participant       | …              |   |

2. **Run**:

   ```bash
   python code/main.py
   ```

   * Enter **sequence length** (number of tests to select)
   * Enter **path** to `normalTests.csv`
   * Choose **fast** (prefix) or **slow** (Lemma 9) method
   * Enter **output** filename; result saved under `output/` as `.txt`

---

## Theoretical Background

### Definition 1 (Precision-Prefix Dominance)

> A covariance matrix $\Sigma$ is **diagonally-dominant** if, after ordering indices so that
>
> $$
>   υ_{l_0}^{-2} \ge υ_{l_1}^{-2} \ge \cdots \ge υ_{l_{K-1}}^{-2},
> $$
>
> the sum of all entries of the inverse of every principal $k$-submatrix
> $\Sigma_{\{l_0,\dots,l_{k-1}\}}^{-1}$ is at least as large as that of **any** other $k$-subset.
> (Here $υ_i^{-2}=1/v_i^2$ is the precision.)

### Corollary 6 (Optimal Prefix)

> If $\Sigma$ satisfies Definition 1, then for **every** $k\le K$, the unique optimal $k$-subset
> that maximizes
> $J(S)=1^\top\Sigma_S^{-1}1$
> is exactly the **first $k$ indices** in the global precision sort.

### Lemma 9 (Brute-Force Optimality)

> Without assuming prefix-dominance, the optimal $k$-subset $S^*$ is the one that
> maximizes
> $J(S)=1^\top\Sigma_S^{-1}1$
> over all $\binom{K}{k}$ choices.

---

## Example: 4×4 Matrix Worked by Hand

Consider

```python
Σ = np.array([
    [4.0, 1.2, 0.5, 0.3],
    [1.2, 2.0, 0.4, 0.6],
    [0.5, 0.4, 3.0, 0.2],
    [0.3, 0.6, 0.2, 5.0]
])
```

We show all steps for selecting $k=3$ tests.

1. **Variances and Precisions**

   * $v^2=[4.0,2.0,3.0,5.0]$
   * Precision = $1/v^2=[0.25,0.50,0.3333,0.20]$.

2. **Global Sort by Precision**

   * Descending order: $(1,2,0,3)$ since
     $0.50>0.3333>0.25>0.20.$

3. **Definition 1: Prefix Checks**

   * **k=1**: Main $\\{1\\}$ has inverse-sum
     $1/2.0=0.50$ vs others $0.3333,0.25,0.20$. ✓

   * **k=2**: Main $\\{1,2\\}$ submatrix
     $\begin{pmatrix}2.0&0.4\\\0.4&3.0\end{pmatrix},$
     inverse-sum ≈ **0.7192**, while
     $\\{1,0\\}$ $\\apprrox$ 0.5650 and $\\{1,3\\}$ $\\approx$ 0.6131. ✓

   * **k=3**: Prefix $\\{1,2,0\\}$ (3×3) also dominates all other triples (omit work for brevity). ✓

   Thus Σ **is** diagonally-dominant.

4. **Corollary 6** → Fast method picks prefix $(1,2,0)$.

5. **Lemma 9 brute-force**:

   ```python
   best_score=-inf; best=None
   for S in combinations(range(4),3):
       inv=inv(Σ[np.ix_(S,S)]); score=inv.sum()
       if score>best_score: best_score, best=S, score
   ```

   yields `best=(1,2,0)`, matching the prefix.

---

*Original method published by Lim, Keppo, and Tan on SSRN.*
